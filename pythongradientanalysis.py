# -*- coding: utf-8 -*-
"""PythonGradientAnalysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZFRP6buOxVO_-HCuLazH2RquVdLmiIiM
"""

from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
import math
from imageio import imread, mimsave
from tempfile import mkstemp
import os

# User defined variables
haxis = True #boolean to determine horizontal or vertical axis. True = Horizontal, False = Vertical
top = 0 #define where you want to crop the image in the y axis
bottom = 900 #define where you want to crop the image in the y axis
left = 200 #define where to analyze in the x axis
right = 900 #define where to analyze in the x axis
plotlines = True # boolean T/F variable if you want to plot the actual measurments across the channel in addition to the average
n = 75 #if plotlines is True, this variable defines how many lines will be plotted
creategif = True #boolean that decides whether the output will be a gif or just the plots
plotsfilename = "plot" # name your plot file name
giffilename = "gradient" #name your gradient file name
frameduration = 0.5 #duration of each frame in the gif
#End user defined variables

ax = plt.subplot(111)  #remove plot frame lines
tempdir = '/content'

pngs = []

gradientpic = Image.open("/content/8hr - 2_XY1620250505_Z0_T00_C0.tiff")
plt.imshow(gradientpic, cmap = 'gray')
#code for horizontal axis
if haxis:
  h,w = np.shape(gradientpic)
  gradientarray = np.zeros((h,w,gradientpic.n_frames))
  #this for loop creates a multidimensional array of the z stack images
  for i in range(gradientpic.n_frames):
    gradientpic.seek(i)
    gradientarray[:,:,i] = np.array(gradientpic)
  print("picture l = " + str(gradientarray.shape[0]) + " picture w = " + str(gradientarray.shape[1])) #width of the picture (could be length since l and w are 512)
  spacing = math.floor((bottom - top)/n) #determines the spacing between lines measured in the gradient
  print("Spacing between lines drawn = " + str(spacing) + " pixels")
  ymax = int (np.amax(gradientarray[top:bottom,left:right,:]))
  print("ymax = " + str(ymax))

  for i in range(gradientpic.n_frames):

    plt.figure(figsize=(12,12)) #set size of plot
    plt.ylim(0, ymax + 1000) #set y axis limit
    plt.xlim([0, right - left])
    ax.spines["top"].set_visible(False)  
    ax.spines["right"].set_visible(False)
    plt.xticks(range(0, right - left, math.floor((right - left)/10)), fontsize=16)  #set tick marks
    plt.yticks(range(0, ymax + 1000, math.floor(ymax/10)), fontsize=16) 
    plt.ylabel("Fluorescence Intensity", fontsize=16)
    plt.xlabel("Distance Across Channel (px)", fontsize=16) 

    if plotlines:
      for j in range (top, bottom, spacing):
        x = np.arange(0, right - left) 
        y = gradientarray[j,left:right,i]
        plt.plot(x, y, color = "grey", lw = 0.1) 

    x = np.arange(0, right - left) 
    y = np.average(gradientarray[top:bottom,left:right,i], axis = 0)
    stdev = np.std(gradientarray[top:bottom,left:right,i], axis = 0) #takes the standard deviation of all the 
    plus_stdev = y + (stdev/2)
    minus_stdev = y - (stdev/2)
    plt.fill_between(x, plus_stdev, minus_stdev, color= "black")
    plt.plot(x, y, color = "white", lw = 2)

    # create file name and append it to a list
    filenum = i
    filename = plotsfilename
    plt.savefig(filename+str(filenum)+".png")
    plt.close()
    pngs.append(filename+str(filenum)+".png")

#same code as the previous one with some variables moved around to measure in the opposite axis
else:
  h,w = np.shape(gradientpic)
  gradientarray = np.zeros((h,w,gradientpic.n_frames))
  #this for loop creates a multidimensional array of the z stack images
  for i in range(gradientpic.n_frames):
    gradientpic.seek(i)
    gradientarray[:,:,i] = np.array(gradientpic)
  print("picture l = " + str(gradientarray.shape[0]) + " picture w = " + str(gradientarray.shape[1])) #width of the picture (could be length since l and w are 512)
  spacing = math.floor((right - left)/n) #determines the spacing between lines measured in the gradient
  print("Spacing between lines drawn = " + str(spacing) + " pixels")
  ymax = int (np.amax(gradientarray[top:bottom,left:right,:]))
  print("ymax = " + str(ymax))
  for i in range(gradientpic.n_frames):

    plt.figure(figsize=(12,9)) #set size of plot
    plt.ylim(0,ymax+1000) #set y axis limit
    plt.xlim([0, bottom - top])
    ax.spines["top"].set_visible(False)  
    ax.spines["right"].set_visible(False)
    plt.xticks(range(0, bottom - top, math.floor((bottom - top)/10)), fontsize=16)  #set tick marks
    plt.yticks(range(0, ymax+1000, math.floor(ymax/10)), fontsize=16) 
    plt.ylabel("Fluorescence Intensity", fontsize=16)
    plt.xlabel("Distance Across Channel (px)", fontsize=16) 

    if plotlines:
      for j in range (left, right, spacing):
        x = np.arange(0, bottom - top) 
        y = gradientarray[top:bottom,j,i]
        plt.plot(x, y, color = "grey", lw = 0.1) 

    x = np.arange(0, bottom - top) 
    y = np.average(gradientarray[top:bottom,left:right,i], axis = 1)
    stdev = np.std(gradientarray[top:bottom,left:right,i], axis = 1)
    plus_stdev = y + (stdev/2)
    minus_stdev = y - (stdev/2)
    plt.fill_between(x, plus_stdev, minus_stdev, color= "black")
    plt.plot(x, y, color = "white", lw = 2)

    # create file name and append it to a list
    filenum = i
    filename = plotsfilename
    plt.savefig(filename+str(filenum)+".png")
    plt.close()
    pngs.append(filename+str(filenum)+".png")


images = []
if creategif:
  for png in pngs:
    img = imread(png)
    images.append(img)
  mimsave(giffilename+".gif", images, duration = frameduration)